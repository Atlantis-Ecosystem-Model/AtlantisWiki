<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Atlantis Documentation – 6. DEFINITIONS OF FUNCTIONAL GROUPS</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Atlantis Documentation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-user-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">User Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-user-guides">    
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part1/index.html">
 <span class="dropdown-text">Part I - Atlantis User Guide</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part2/index.html">
 <span class="dropdown-text">Part II - [Coming Soon]</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../confluence/index.html"> 
<span class="menu-text">Confluence Wiki</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resources/index.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../user_guides/quarto_site/part1/07-definitions-of-functional-groups.html">6. Definitions of Functional Groups</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/01-foreward.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">0. Foreword</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/02-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/03-installation-and-running.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Installation and Running</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/04-geometry-of-the-model-domain.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Geometry of the Model Domain</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/05-hydrodynamic-salinity-and-temperature-forcing-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. Hydrodynamic, Salinity and Temperature Forcing Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/06-the-physics-submodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. The Physics Submodel</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/07-definitions-of-functional-groups.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">6. Definitions of Functional Groups</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/08-run-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. Run Parameters</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/09-force-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. Force Parameters</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/10-primary-producer-processes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. Primary Producer Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/11-consumer-processes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. Consumer Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/12-distribution-and-movement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. Distribution and Movement</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/13-processes-in-bacterial-and-inanimate-pools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">12. Processes in Bacterial and Inanimate Pools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/14-influence-of-environmental-factors-on-ecological-p.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">13. Influence of Environmental Factors on Ecological Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/15-final-overview-of-ecology-routines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">14. Final Overview of Ecology Routines</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/16-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/17-appendix-1-tips-for-calibrating-biological-model-n.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Appendix 1: Tips for Calibrating Biological Model</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-to-functional-groups" id="toc-introduction-to-functional-groups" class="nav-link active" data-scroll-target="#introduction-to-functional-groups"><strong>6.1. Introduction to functional groups</strong></a></li>
  <li><a href="#defining-functional-groups" id="toc-defining-functional-groups" class="nav-link" data-scroll-target="#defining-functional-groups"><strong>6.2. Defining functional groups</strong></a></li>
  <li><a href="#defining-the-grouptype-correctly" id="toc-defining-the-grouptype-correctly" class="nav-link" data-scroll-target="#defining-the-grouptype-correctly"><strong>6.3. Defining the GroupType correctly</strong></a></li>
  <li><a href="#modifying-functional-groups-in-parameterised-models" id="toc-modifying-functional-groups-in-parameterised-models" class="nav-link" data-scroll-target="#modifying-functional-groups-in-parameterised-models"><strong>6.4. Modifying functional groups in parameterised models</strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">6. DEFINITIONS OF FUNCTIONAL GROUPS</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction-to-functional-groups" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-functional-groups"><strong>6.1. Introduction to functional groups</strong></h2>
<p><strong><em>Types of functional groups</em></strong></p>
<p>Biological components are represented as <strong>biomass pools</strong> (most non-vertebrates), <strong>age-structured biomass pools</strong> (some invertebrates) or <strong>age-structured groups</strong> (vertebrates). These three group types are assigned according to the GroupType and NumCohorts parameters given in the <em>functional_groups.csv</em> file (Table 8). Group types FISH, FISH_INVERT, SHARK, MAMMAL, BIRD, REPTILE are assigned to the fully age-structured groups with the number of age groups given by NumCohorts. Other groups are assigned to biomass pools. If NumCohorts for a biomass pool is &gt;1 they will be assigned to an age-structured biomass pool. The age-structured biomass pools are similar to stanzas used in, for example, Ecosim and are used to allow for different juvenile and adult behaviour and parameters. All non-vertebrates that have NumCohorts=1 are assigned to simple biomass pools.</p>
<table class="caption-top">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><p><strong>NOTE!</strong></p>
<p><strong>Can a non-vertebrate be modelled as an age-structured group?</strong></p>
<p>Six GroupTypes (FISH, FISH_INVERT, MAMMAL, SHARK, BIRD and REPTILE) are currently modelled as age-structured groups. If full age-structure is needed for a non-vertebrate, it should be set as one of these groups, most likely as FISH_INVERT or FISH. FISH_INVERT currently uses the same code as FISH, but the intent is to use it to represent a size rather than age-based model, which is a more typical representation for key invertebrates (such as exploited species). Note however that setting a group as FISH_INVERT or FISH would not call typical non-vertebrate routines (see below).</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>Atlantis does not explicitly model sex, but represents an average individual. This means that all individuals in a biomass pool and an age cohort (or a genotype in a cohort, if multiple genotypes are modelled) are considered identical in terms of their reproductive output. This may require some caution in parameterisation, e.g.&nbsp;number of offspring per mammal individual.</p>
<p><strong><em>State variables tracked</em></strong></p>
<p><em>Main model</em></p>
<p>In models that are based on N only (i.e.&nbsp;do not explicitly track P and C) the only state variable tracked for most biomass pools is N, but both N and Si fluxes are tracked for Si limited biomass pools, such as diatoms. The Si limited groups are identified from the <em>functional_groups.csv</em> file parameter IsSiliconDep (see below). In age-structured groups three variables are tracked for each age cohort: reserve N (RN), structural N (SN) and numbers (Num). In addition, fluxes in the water column and sediments are tracked through eight <strong>inanimate pools</strong>: ammonia (NH), nitrate (NO), dissolved silica (Si), detrital silica (DSi), dissolved oxygen (O2), dissolved organic nitrogen (DON), labile detritus (DL), and refractory detritus (DR). An additional inanimate pool, carrion (DC), is also required, though it is only dynamically used if the fisheries submodel is active; DC is then used to represent fisheries discards. State variables tracked for each group defined with the GroupType parameter in the <em>functional_groups.csv</em> file are listed in Table 8.</p>
<p><em>Extended models</em></p>
<p>If the model also includes tracking of P and C (trackAtomicRatio is set to 1 in <em>run.prm</em>), then P and C pools are tracked for each functional group, together with N pools. Additional inanimate pools are for C and P are also required. If the model is of an estuary (FlagIsEstuary=1 in <em>run.prm</em> file) a sediment (SED) inanimate pool is added for the water column. If the model tracks contaminants (track_contaminants=1 in <em>run.prm</em>) a separate pool is added for each contaminant for each nitrogen pool tracked, so that concentration of contaminants can be tracked throughout the entire food web. If the model spans polar regions (flagIsPolar=1 in <em>run.prm</em>) the model allows for 24 hours of night/daylight seasonally.</p>
<p><strong><em>Allocation of pools throughout the vertical dimension: water column, epibenthos and sediment</em></strong></p>
<p>Atlantis models 3-5 explicit distribution types of organisms and inanimate pools through the model domain – <strong>water column</strong>, <strong>epibenthic layer</strong> and <strong>sediments</strong> are tracked in all models and <strong>ice</strong> and <strong>land</strong> may also optionally be included. The water column and <strong>sediment</strong> are modelled as three dimensional spaces (units of variables are in m<sup>3</sup>), whereas the epibenthic layer is two-dimensional (units in m<sup>2</sup>). Most organisms are restricted to one type, such as sediments (infaunal invertebrates identified with INF in GroupType name), epibenthic layer (epibenthic organisms, identified with EP in the GroupType name) or water column (fully age-structured groups). Some of the smaller groups (e.g.&nbsp;microflora primary producers) and the inanimate pools can exist in both the sediments and water column (Table 8).</p>
<p>In the Atlantis code the water column, epibenthic, sediment, ice and land distributionns are referred to as “habitatType”. However, remember that they are not the same as the ecological epibenthic habitats modelled in Atlantis (e.g.&nbsp;seagrass, corals, sponges etc.).</p>
<table class="caption-top table">
<caption><span id="_Toc526762760" class="anchor"></span>Table 8. State variables tracked in the main Atlantis model (no ice or land included). * indicates optional Si tracking in primary producers that are limited by Si. Primary producer Si limitation is set in <em>functional_groups.csv</em> file parameter IsSiliconDep (see Table 9). In models that include C and P, both C and P are tracked like N (so the number of variable tracked is three times larger).</caption>
<thead>
<tr class="header">
<th><strong>Group</strong></th>
<th><strong>State variables tracked</strong></th>
<th><strong>GroupType in CSV file or <em>initial_conditions.nc</em></strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><em>Biomass pools</em></strong></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>pelagic <strong>bacteria</strong></td>
<td>N in water column</td>
<td>PL_BACT</td>
</tr>
<tr class="odd">
<td>sediment <strong>bacteria</strong></td>
<td>N in sediments</td>
<td>SED_BACT</td>
</tr>
<tr class="even">
<td><p><strong><em>(Age-structured) biomass pools</em></strong></p>
<p>These groups can be age structured if NumCohorts set &gt; 1</p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>non epibenthic <strong>primary producers</strong></td>
<td><p>N in water column</p>
<p>N in sediments</p>
<p>*Si in water column</p>
<p>*Si in sediments</p>
<p>NOTE: Age-structure not recommended</p></td>
<td><p>SM_PHY</p>
<p>LG_PHY</p>
<p>MICROPHTYBENTHOS</p>
<p>DINOFLAG</p></td>
</tr>
<tr class="even">
<td>epibenthic <strong>primary producers</strong></td>
<td>N in epibenthic layer for each age group defined by NumCohorts parameter. If age-structure is selected for SEAGRASS it is not really age structure, but different parts of the plant – with “age 0” assumed to be the pool representing leaves, “age 1” the roots, and “age 2” the epiphytes on the leaves, see details <a href="https://confluence.csiro.au/display/Atlantis/2012/12/12/new+seagrass+modelling+option">here</a></td>
<td><p>PHYTOBEN</p>
<p>SEAGRASS</p></td>
</tr>
<tr class="odd">
<td>infaunal <strong>invertebrates</strong></td>
<td><p>N in sediments for each age group defined by the NumCohorts parameter.</p>
<p>NOTE: Not typically age-structured</p></td>
<td><p>SM_INF</p>
<p>LG_INF</p></td>
</tr>
<tr class="even">
<td>epibenthic <strong>invertebrates</strong></td>
<td>N in epibenthic layer for each age group defined by the NumCohorts parameter</td>
<td><p>SED_EP_FF</p>
<p>SED_EP_OTHER</p>
<p>MOB_EP_OTHER</p>
<p>CORAL</p>
<p>SPONGE</p></td>
</tr>
<tr class="odd">
<td>water column <strong>invertebrates</strong></td>
<td>N in water column for each age group defined by the NumCohorts parameter</td>
<td><p>SM_ZOO</p>
<p>MED_ZOO</p>
<p>LG_ZOO</p></td>
</tr>
<tr class="even">
<td>land <strong>plants</strong></td>
<td>N on land for each age group defined by the NumCohorts parameter</td>
<td><p>MARSH</p>
<p>MANGROVE</p></td>
</tr>
<tr class="odd">
<td>large invertebrates</td>
<td>N in water column for each age group defined by NumCohorts parameter</td>
<td><p>CEP</p>
<p>PWN</p></td>
</tr>
<tr class="even">
<td><strong><em>Age-structured groups</em></strong></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>vertebrates</td>
<td><p>RN in water column</p>
<p>SN in water column</p>
<p>Num in water column</p>
<p>for each cohort defined in</p>
<p>NumCohorts parameter</p></td>
<td><p>FISH</p>
<p>SHARK</p>
<p>MAMMAL</p>
<p>BIRD</p>
<p>REPTILE</p></td>
</tr>
<tr class="even">
<td>size/age structured invertebrates of particular interest</td>
<td><p>RN in water column</p>
<p>SN in water column</p>
<p>Num in water column</p>
<p>for each cohort defined in</p>
<p>NumCohorts parameter</p></td>
<td>FISH_INVERT</td>
</tr>
<tr class="odd">
<td><strong><em>Inanimate pools</em></strong></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Ammonia</td>
<td><p>NH3 in water column</p>
<p>NH3 in sediments</p></td>
<td>NH</td>
</tr>
<tr class="odd">
<td>Nitrate</td>
<td><p>NO3 in water column</p>
<p>NO3 in sediments</p></td>
<td>NO</td>
</tr>
<tr class="even">
<td>Oxygen</td>
<td><p>O2 in water column</p>
<p>O2 in sediments</p></td>
<td>O2</td>
</tr>
<tr class="odd">
<td>Dissolved organic nitrogen</td>
<td><p>DON in water column</p>
<p>DON in sediments</p></td>
<td>DON</td>
</tr>
<tr class="even">
<td>Dissolved silica</td>
<td>Si in water column</td>
<td>Si</td>
</tr>
<tr class="odd">
<td>Detrital silica</td>
<td>DSi in water column</td>
<td>DSi</td>
</tr>
<tr class="even">
<td>Labile detritus</td>
<td><p>N in water column</p>
<p>N in sediments</p></td>
<td>LAB_DET</td>
</tr>
<tr class="odd">
<td>Refractory detritus</td>
<td><p>N in water column</p>
<p>N in sediments</p></td>
<td>REF_DET</td>
</tr>
<tr class="even">
<td>Carrion (only dynamically tracked if fisheries are active)</td>
<td><p>N in water column</p>
<p>N in sediments</p></td>
<td>CARRION</td>
</tr>
<tr class="odd">
<td>Sediment (only if flagIsEstuary=1)</td>
<td>SED in water column</td>
<td>SED</td>
</tr>
</tbody>
</table>
<p><strong><em>Timestep of the model</em></strong></p>
<p>The timestep at which most processes are repeated is typically an <em>adaptive</em> daily (24h) or diurnal (12h) timestep, though tidal models with shorter timesteps (3h or 6h) also exist. This timestep is specified as dt in the <em>run.prm</em> file. Reproduction, recruitment and migration occur less frequently, typically once per year.</p>
<p>The <em>adaptive timestep</em> means that for most of the groups the processes are repeated once per timestep, but for small organisms, such as bacteria and phytoplankton the timestep is reduced to ensure that fluxes into and out of the component with the fastest turnover rates remain stable and numerical artifacts are not introduced into the mathematical solution scheme. The length of the adaptive timestep for such groups is determined to ensure that the relative change (flux) in any variable does not exceed a pre-specified proportion of the standing stock – this tolerance is set in the <em>biology.prm</em> file. The adaptive timestep changes through time, depending on the standing stock of these groups and the temperature, nutrient availability and other factors that affect the turnover rates in these “fast” variables.</p>
<p><strong><em>Biological processes modelled</em></strong></p>
<p>The modelled biological processes include primary production, bacterial processes, feeding, assimilation, waste production, explicit respiration (optional and not used in most models), growth, movement and migration, non-predation mortality, maturation, reproduction and recruitment. In biomass pools all processes are modelled through biomass (nitrogen) turnover. In age-structured groups, the state variables are numbers-at-age and weight-at-age (tracked as reserve and structural nitrogen) which can be converted to biomass.</p>
</section>
<section id="defining-functional-groups" class="level2">
<h2 class="anchored" data-anchor-id="defining-functional-groups"><strong>6.2. Defining functional groups</strong></h2>
<p>The functional group input file sets all the biological groups in the model. It can be set in CSV or XML format (see examples <a href="https://confluence.csiro.au/display/Atlantis/Functional+Group+Definition+File">here</a>). The number of groups is entirely flexible, but each model must include three obligatory detritus groups: carrion (CARRION), labile detritus (LAB_DET) and refractory detritus (REF_DET).</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: left;">The <em>functional_groups.csv</em> file defines the biological groups used in the model and some of their key characteristics. These characteristics are used throughout the code to apply different appropriate routines for the group. The number of groups in the <em>functional_groups.csv</em> file must match the number given in the K_num_tot_sp parameter in the <em>run.prm</em> file. The detritus groups must be defined as the last three groups in the file.</td>
</tr>
</tbody>
</table>
<hr>
<p>Currently each group must have the following parameters (characteristics). For new updates, check the Atlantis wiki <a href="https://confluence.csiro.au/display/Atlantis/Functional+Group+Definition+File">functional group page</a></p>
<table class="caption-top table">
<caption><span id="_Toc526762761" class="anchor"></span>Table 9. Parameters in the <em>functional_groups.csv</em> file.</caption>
<thead>
<tr class="header">
<th><strong>Parameter name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GroupCode</td>
<td><u>2 or 3 letter code</u> of upper case letters used to identify each functional group. Atlantis will display an error message and quit if the group codes are not the correct format. This code is very important and applied to all functional group specific parameters</td>
</tr>
<tr class="even">
<td>Index</td>
<td>An index of the group. Atlantis doesn't actually read this in but it is helpful for modellers to see as it defines the order of read-in for species vectors and the group ID number if you are trying to activate some of the debug/calibration fprintf statements using whichcheck in the <em>run.prm</em> file. The index must start form 0, as this is how the C programing language counts</td>
</tr>
<tr class="odd">
<td>IsTurnedOn</td>
<td><p>A boolean value (either 0 (false) or 1 (true)) to indicate if the group is active in the current model run. If the group is not active it will be excluded from the model.</p>
<p>This option allows the user to exclude some groups from the model without having to setup new initial conditions and parameter files.</p></td>
</tr>
<tr class="even">
<td>Name</td>
<td>Name of a group. This must match the tracer names in the <em>initial_conditions.nc</em> file as it used to find the tracers in the <em>initial_conditions.nc</em> input file.</td>
</tr>
<tr class="odd">
<td>LongName</td>
<td>The long name written to the NetCDF output files. This name can be a few words long and ideally should be informative. This is especially important when sharing the model with others.</td>
</tr>
<tr class="even">
<td>NumCohorts</td>
<td><p>The number of cohorts in a functional group. If the value is &gt; 1 the groups is assumed to be age-structured (either an age-structured biomass pool or age-structured group).</p>
<p>In the earlier Atlantis versions age structured groups all had to have 10 cohorts. This is now relaxed and there is no upper limit on the number of age-groups to model (but remember, the more age groups the slower the model will run).</p></td>
</tr>
<tr class="odd">
<td>NumGeneTypes</td>
<td>Number of discrete phenotypes in each age group. This option is used when simulating evolution or multiple size-at-age representations and should only be set to &gt;1 if flag_do_evolution is set to 1 in <em>biology.prm</em> file. If more than one phenotype is present, initial conditions will be have to be set up for each phenotype.</td>
</tr>
<tr class="even">
<td>NumStages</td>
<td>This parameter describes the number of separate stages in a functional group, which are set to 1 or 2 if juvenile and adult stages have separate parameters for distribution, mortality, migration, feeding and others. In principle, more than 2 stages are possible, although this has not been tested. Typically all age-structured groups have 2 stages, but age-structured biomass pools can also have separate parameters for juvenile and adult stages and thus have 2 stages.</td>
</tr>
<tr class="odd">
<td>NumSpawns</td>
<td>Number of spawns in the year. Typically one per year, but more than one is possible (especially for ages structured biomass pool groups). The timing of spawn is given in Time_Spawn_XXX parameter in <em>biology.prm</em> file (if NumSpawns is 1 it expects a single value, otherwise it expects a vector of length NumSpawns).</td>
</tr>
<tr class="even">
<td>NumAgeClassSize</td>
<td>Number of calendar years in one age group. This can be set to be anything between a few months to many years and allows simulation of different longevity organisms without having to setup too many age groups (which reduces simulation speed). Note, all individuals in an age group are considered identical (unless different phenotypes are set in NumGeneTypes, in which case all individuals in one phenotype of one age group are identical). However, the proportion of an age group per annual cohort is tracked so that recruitment variation is represented through time and not homogenized away (see chapter 10.9.6).</td>
</tr>
<tr class="odd">
<td>NumStocks</td>
<td><p>This sets the number of geographically distinct stocks for age-structured groups and age-structured biomass pools. The stocks must occupy different boxes or layers, i.e.&nbsp;they do not spatially overlap.</p>
<p>Some biological parameters, like vulnerability to prey can be set as stock specific, which allows for better tuning. It has been applied to some groups that are known to include ecologically distinct stocks in different geographic areas. If NumStocks &gt;1 then the corresponding number of stock specific parameters will be required in the <em>biology.prm</em> input file</p></td>
</tr>
<tr class="even">
<td>VerticallyMigrates</td>
<td>If true then the group can move vertically through the water column. This should be set to 1 except for debugging purposes. If this is set to 0, no vertical movement will happen even if it is specified in the <em>biology.prm</em> file and the vertical distribution of individuals in the <em>initial_conditions.nc</em> file will be retained throughout the simulation.</td>
</tr>
<tr class="odd">
<td>HorizontallyMigrates</td>
<td>If true then the group can move horizontally throughout the model as well as migrate out of the model. No migration will happen if this is set to 0. Biomass pool groups which are marked as passive in the <em>initial_conditions.nc</em> will still be advected even if HorizontallyMigrates is set to 0.</td>
</tr>
<tr class="even">
<td>NumMigrations</td>
<td>The number of migrations per calendar year</td>
</tr>
<tr class="odd">
<td>MultiYrMigrations</td>
<td>Whether any of the migrations are multi-year (1) or simply annual (0). While this column is always required in the groups definition file the associated code will not function unless flag_multiyr_migs is also set to 1 in the <em>run.prm</em> file</td>
</tr>
<tr class="even">
<td>ExternalReproduction</td>
<td>This is whether the group reproduces outside the model (i.e.&nbsp;the value for Time_Spawn_XXX parameter in <em>biology.prm</em> file is set during a day of the year when the species should be outside the model)</td>
</tr>
<tr class="odd">
<td>RecruitType</td>
<td><p>This is where you set the recruitment typ:</p>
<p>0 = independent distribution (use recruit_hdistrib)</p>
<p>1 = at parental locations</p>
<p>2 = external (into Migration Array)</p>
<p>3 = using a forced larval dispersal matrix</p>
<p>4 = external reproducer who has parental care</p></td>
</tr>
<tr class="even">
<td>IsFished</td>
<td>If set to 1 the group can be fished (targeted) by commercial or recreational fisheries and the catch will be reported in the output files, and is analysed in the assessment model. Note that if set to 0, dynamic fishing will still occur if parameters are given in the <em>harvest.prm</em> file.</td>
</tr>
<tr class="odd">
<td>IsImpacted</td>
<td><p>If true then the group can be impacted by fishing, bycatch or incidental fishing related mortality (e.g.&nbsp;destruction of living habitats). This parameter differentiates between targeted and accidental interactions; it is not reported in the landings. This means there must be values in the harvest files for this group. Note the group can be impacted by bycatch/incidental mortality even if no explicit targeted fishing is setup. This means the bycatch/incidental mortality parameters should be assessed carefully in the <em>harvest.prm</em> file.</p>
<p>If both this value and IsFished are set to 0 then all fisheries related impacts on the group are disabled.</p></td>
</tr>
<tr class="even">
<td>isTAC</td>
<td>If true, the group will be under total allowable catch (TAC) management. It will activate specific TAC related code in the Harvest submodel.</td>
</tr>
<tr class="odd">
<td>GroupType</td>
<td><p>The type of species. This is one of the most important parameters, as it tells Atlantis what kind of organism the functional group is representing and what kind of processes should be applied to it. Six group types are allowed for age-structured groups. A lot more group types are available to define invertebrate biomass pool types and these group types are used to dictate the adaptive timestep for simulating proceses, and all of them have some specialized ecological routines applied (see some details about their characteristics <a href="https://confluence.csiro.au/display/Atlantis/AtlantisGroupTypes">here</a>).</p>
<p>The main Atlantis model groups include:</p>
<p><em>AGE STRUCTURED GROUPS</em></p>
<ol type="1">
<li><p>Standard fin-fish or generic vertebrate FISH</p></li>
<li><p>Size/age-structured invertebrate FISH_INVERT</p></li>
<li><p>Chondrichthyans SHARK</p></li>
<li><p>Birds BIRD</p></li>
<li><p>Marine mammanls (potentially terrestrial mammals in the future) MAMMAL</p></li>
<li><p>Reptiles (can be present in the water and on land) REPTILE.</p></li>
</ol>
<p><em>BIOMASS POOL GROUPS</em></p>
<p><strong>Phytoplankton</strong></p>
<ol start="7" type="1">
<li><p>Small Phytoplankton SM_PHY</p></li>
<li><p>Large Phytoplankton LG_PHY (used in combination with IsSiliconDep to define diatoms)</p></li>
<li><p>Trichodesmium and Cyanobacteria TRICHO (N fixers)</p></li>
</ol>
<p><strong>Other primary producers</strong></p>
<ol start="10" type="1">
<li><p>Microphtybenthos MICROPHTYBENTHOS</p></li>
<li><p>Dinoflagellates DINOFLAG</p></li>
<li><p>Phytoben PHYTOBEN (typically used to represent macroalgae)</p></li>
<li><p>Seagrass SEAGRASS</p></li>
<li><p>Turf TURF</p></li>
</ol>
<p><strong>Zooplankton</strong></p>
<ol start="15" type="1">
<li><p>Small Zooplankton SM_ZOO</p></li>
<li><p>Medium Zooplankton MED_ZOO</p></li>
<li><p>Large Zooplankton LG_ZOO</p></li>
<li><p>Jellyfish JELLIES (in the past represented as LG_ZOO)</p></li>
</ol>
<p><strong>Large pelagic invetebrates</strong></p>
<ol start="19" type="1">
<li><p>Cephalopod CEP</p></li>
<li><p>Prawns PWN</p></li>
</ol>
<p><strong>Infauna</strong></p>
<ol start="21" type="1">
<li><p>Small Infauna SM_INF</p></li>
<li><p>Large Infauna LG_INF</p></li>
</ol>
<p><strong>Epibenthic organisms</strong></p>
<ol start="23" type="1">
<li><p>Sediment epibenthic filter feeders SED_EP_FF (often used for bivalves, sponges)</p></li>
<li><p>Benthic grazers SED_EP_OTHER</p></li>
<li><p>Mobile epibenthos MOB_EP_OTHER (often used for crabs, lobster, octopus)</p></li>
<li><p>Corals CORAL</p></li>
<li><p>Sponges SPONGE</p></li>
</ol>
<p><strong>Bacteria</strong></p>
<ol start="28" type="1">
<li><p>Pelagic Bacteria PL_BACT</p></li>
<li><p>Sediment Bacteria SED_BACT</p></li>
</ol>
<p><strong>Obligatory detritus groups</strong></p>
<ol start="30" type="1">
<li><p>Carrion CARRION</p></li>
<li><p>Labile detritus LAB_DET</p></li>
<li><p>Refractory detritus REF_DET</p></li>
<li><p>Additional ice and land based groups are also available.</p></li>
</ol>
<p><strong>Ice dwelling</strong></p>
<ol start="34" type="1">
<li><p>ICE_BACT</p></li>
<li><p>ICE_MIXOTROPHS</p></li>
<li><p>ICE_DIATOMS</p></li>
<li><p>ICE_ZOOBIOTA</p></li>
</ol>
<p><strong>Land dwelling</strong> (vegetation only for now)</p>
<ol start="38" type="1">
<li><p>MARSH</p></li>
<li><p>MANGROVE</p></li>
</ol></td>
</tr>
<tr class="even">
<td>IsPredator</td>
<td>If true then the group is assumed to eat other groups by the assessment code (for the purposes of defining network indices etc), it does not affect the ecological model.</td>
</tr>
<tr class="odd">
<td>IsCover</td>
<td><p>If true the group is classified as a habitat. This means that the group becomes a unique habitat type, that can be used by other groups in the model for shelter etc, in addition to the general four geological habitat types included by default (<strong>reef, flat, soft, canyon).</strong></p>
<p>For example, if IsCover is set to 1 for three functional groups (e.g.&nbsp;BFS, BFF, and MA), the model has a total of seven habitat types. In this case the habitat dependency parameter habitat_XXX in the <em>biology.prm</em> file must have 7 values for each functional group. The living habitats are always the first entries and the geological classes always the last 4 entries. So in this example, the first three entries will refer to the IsCover groups in the order they are listed in the <em>functional_groups.csv</em> file and the last four entries will refer to reef, flat, soft, canyon habitats.</p></td>
</tr>
<tr class="even">
<td>IsSiliconDep</td>
<td>If true, the group is assumed to be Si limited and its energy flows are tracked both through nitrogen and silicon. All Si limited groups must have separate Si tracers set in the <em>initial_conditions.nc</em>, in addition to the usual Nitrogen tracers. At present most models have this set to true for Diatoms and MicroPhytopbenthos.</td>
</tr>
<tr class="odd">
<td>IsAssessed</td>
<td>If true then this group will be assessed in the Assessment submodel. This submodel will generate a number of assessment indices.</td>
</tr>
<tr class="even">
<td>IsCatchGrazer</td>
<td>If true, the group grazes on catch, for instance pinnipeds that eat fish from nets. If set to 1 for a functional group XXX, then availability of catch of each functional group should be given for this group in the pFCXXX parameter in the <em>biology.prm</em> file. The pFC parameters are not required for groups that are not catch grazers.</td>
</tr>
<tr class="odd">
<td>OverWinters</td>
<td>If true, this group will go into hiatus over winter. The overwintering can be triggered and ended by time of the year or temperature. This is set using overwinterStartTofY_XXX, overwinterEndTofY_XXX, overwinterStartTemp_XXX, overwinterEndTemp_XXX parameters in the <em>biology.prm</em> file. These parameters only have to be set for overwintering groups.</td>
</tr>
<tr class="even">
<td>isCultured</td>
<td>This identifies aquaculture groups, and applies aquaculture processes to them. Parameters required for aquaculture groups are described <a href="https://confluence.csiro.au/display/Atlantis/2014/03/06/Aquaculture">here</a>.</td>
</tr>
<tr class="odd">
<td>isHabDepend</td>
<td>Identifies groups that are habitat dependent. Note, this value takes precedence over habitat preference parameters in the <em>biology.prm</em> file. If isHabDepend is set to 0 then the group is not affected by habitats, even if appropriate parameters are given in the <em>biology.prm</em></td>
</tr>
<tr class="even">
<td>numMoveEntries</td>
<td>The number of movement time periods you would like the group to have. Historically this has been fixed at 4 to allow for seasonal movement, but currently any number of moves is allowed. See further details on parameters in <em>biology.prm</em> <a href="https://confluence.csiro.au/pages/viewpage.action?pageId=346916326">here</a></td>
</tr>
<tr class="odd">
<td>isBioEroder</td>
<td>Whether the group bioerodes corals (i.e.&nbsp;sponges). This allows for boring sponges and bioeroder activities in reef models including corals and sponges</td>
</tr>
<tr class="even">
<td>isSupplemented</td>
<td>Whether the group feeds on material from outside the model. If this is set to 1, the group will be assumed to be eating insects or pellets or something from outside the model domain. The proportion of their diet gained in this way (per box) must be set using the Supp_XXX in the <em>biology.prm</em> file.</td>
</tr>
<tr class="odd">
<td>isExternal</td>
<td>Flag to indicate whether the group uses the external population model option (instead of simply holding individuals in hiatus when they have migrated out of the model).</td>
</tr>
<tr class="even">
<td>isLandActive</td>
<td>Marks the group as able to be on land (for models with land and sea). Only required if flagAllowLand is set to 1 in the <em>run.prm</em> file.</td>
</tr>
<tr class="odd">
<td>isLightEffected</td>
<td>Marks the group as susceptible to light pollution. Only required if flag_pollutant_impacts is set to 1 in the <em>run.prm</em> file.</td>
</tr>
<tr class="even">
<td>isNoiseEffected</td>
<td>Marks the group as susceptible to noise pollution. Only required if flag_pollutant_impacts is set to 1 in the <em>run.prm</em> file.</td>
</tr>
</tbody>
</table>
<table class="caption-top">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><p><strong>NOTE!</strong></p>
<p><strong>What is the role of detritus in an ecosystem model? An excerpt from Murray and Parslow (1997) PPBIM report:</strong></p>
<p>“The detrital pool acts as a store of fixed nutrient, which introduces a delay into nutrient recycling. Particulate detritus sinks and thereby transports nutrients out of the surface layer into deep water or to the sediment. Dissolved organic matter (DOM) does not sink, and very large pools of refractory DOM are found in the open ocean and in coastal waters. Horizontal transport of particulate detritus and DOM from regions of high production to more oligotrophic areas can also be important”</p>
<p>“Three forms of non-living organic matter are included in the model: labile particulate detritus, refractory particulate detritus and dissolved organic matter [NOTE – these same pools, plus Carrion, are included in Atlantis, which is based on the PPBIM]. These are represented by the symbols DL, DR and DON respectively. The particulate detrital pool [in nature] contains a wide variety of particles, with diverse sources, ages, sizes and chemical composition. The model includes two functional components: fresh labile detritus breaking down on time scales of a few days, and semi-refractory detritus turning over on time scales of a year. This allows the model to treat perturbations to the nutrient cycle on time scales of days to years.”</p>
<p>“[In nature] The pool of dissolved organic matter also contains a variety of compounds with diverse turnover rates. In oceanic waters there is a large pool of highly refractory DOM, whose average age has been estimated to be as much as 3400 years (Williams 1975). The bulk of this material is essentially irrelevant for the cycling of nutrients on the time scales of [model] interest. However the DOM pool also includes much more labile components. Highly labile sugars and amino acids released through cell lysis or messy feeding may be consumed by bacteria or break down on time scales of hours (Fuhrman 1987) to days (Holibaugh and Azam 1983). This material is not modelled explicitly, but is treated as though it was remineralised immediately to form dissolved inorganic nutrient. The model includes a single DOM pool with an assumed turnover time of the order of a hundred days. … Because it turns over on time scales, which are long compared with both phytoplankton uptake of inorganic N, and transport within the Bay, it plays a role in reducing N sequestration in coastal waters.”</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
</section>
<section id="defining-the-grouptype-correctly" class="level2">
<h2 class="anchored" data-anchor-id="defining-the-grouptype-correctly"><strong>6.3. Defining the GroupType correctly</strong></h2>
<p>The definition of a group is very important as it will determine the ecological routines and the adaptive timestep applied for the group (see timestep description in chapter 6.1). Table 10 shows routines that are called for different group types. The routines are further modified depending on whether consumers live in the water column or sediment.</p>
<table class="caption-top table">
<caption><span id="_Toc526762762" class="anchor"></span>Table 10. Routines called for different non-vertebrate GroupTypes in Atlantis code. The <em>Call_Group_Process_Function()</em> routine in atecology.c determines the specific routine used from the atGroupProcess.c file non vertebrate groups. Note, that the greatest diversity ofroutines are called for different benthic invertebrate types (for clarity benthic invertebrates are shown in <em>bold italics</em>).</caption>
<colgroup>
<col style="width: 42%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Routine name in Atlantis code</strong></th>
<th><strong>GroupType for which the routine is applied</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>Dinoflag_Process()</em></td>
<td><p>DINOFLAG</p>
<p>ICE_MIXOTROPHS</p></td>
</tr>
<tr class="even">
<td><em>Phytoplankton_Process()</em></td>
<td><p>LG_PHY</p>
<p>SM_PHY</p>
<p>PHYTOBEN</p>
<p>SEAGRASS</p>
<p>MICROPHTYBENTHOS</p>
<p>TURF</p>
<p>ICE_DIATOMS</p></td>
</tr>
<tr class="odd">
<td><em>Invert_Consumers_Process()</em></td>
<td><p><strong><em>SM_INF</em></strong></p>
<p><strong><em>LG_INF</em></strong></p>
<p>SM_ZOO</p>
<p>MED_ZOO</p>
<p>LG_ZOO</p>
<p>CEP</p>
<p>PWN</p>
<p>ICE_ZOOBIOTA</p></td>
</tr>
<tr class="even">
<td><em>Epibenthic_Invert_Process()</em></td>
<td><p><strong><em>SED_EP_FF</em></strong></p>
<p><strong><em>MOB_EP_OTHER</em></strong></p></td>
</tr>
<tr class="odd">
<td><em>Sediment_Epi_Other_Process()</em></td>
<td><strong><em>SED_EP_OTHER</em></strong></td>
</tr>
<tr class="even">
<td><em>Coral_Process()</em></td>
<td><p>CORAL</p>
<p>SPONGE</p></td>
</tr>
<tr class="odd">
<td><em>Pelagic_Bacteria_Process()</em></td>
<td>PL_BACT</td>
</tr>
<tr class="even">
<td><em>Ice_Bacteria_Process()</em></td>
<td>ICE_BACT</td>
</tr>
<tr class="odd">
<td><em>Sediment_Bacterica_Process()</em></td>
<td>SED_BACT</td>
</tr>
<tr class="even">
<td><em>Labile_Detritus_Process()</em></td>
<td>LAB_DET</td>
</tr>
<tr class="odd">
<td><em>Refractory_Detritus_Process()</em></td>
<td>REF_DET</td>
</tr>
<tr class="even">
<td><em>Carrion_Process()</em></td>
<td>CARRION</td>
</tr>
</tbody>
</table>
</section>
<section id="modifying-functional-groups-in-parameterised-models" class="level2">
<h2 class="anchored" data-anchor-id="modifying-functional-groups-in-parameterised-models"><strong>6.4. Modifying functional groups in parameterised models</strong></h2>
<p>Details on how to add a new functional group into an existing model are given on the wiki <a href="https://confluence.csiro.au/display/Atlantis/Adding+a+new+group">here</a>. This will require a significant effort and reparameterisation of the model.</p>
<p>Alternatively, if changes to functional groups are needed, it might be easier to use an existing group and change it into something new. You may not want to change the three letter code, as that would involve changing all the parameter names for the group.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>