<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Atlantis Documentation – 3. GEOMETRY OF THE MODEL DOMAIN</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Atlantis Documentation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-user-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">User Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-user-guides">    
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part1/index.html">
 <span class="dropdown-text">Part I - Atlantis User Guide</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part2/index.html">
 <span class="dropdown-text">Part II - [Coming Soon]</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../confluence/index.html"> 
<span class="menu-text">Confluence Wiki</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resources/index.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../user_guides/quarto_site/part1/04-geometry-of-the-model-domain.html">3. Geometry of the Model Domain</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/01-foreward.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">0. Foreword</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/02-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/03-installation-and-running.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Installation and Running</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/04-geometry-of-the-model-domain.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">3. Geometry of the Model Domain</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/05-hydrodynamic-salinity-and-temperature-forcing-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. Hydrodynamic, Salinity and Temperature Forcing Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/06-the-physics-submodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. The Physics Submodel</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/07-definitions-of-functional-groups.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Definitions of Functional Groups</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/08-run-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. Run Parameters</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/09-force-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. Force Parameters</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/10-primary-producer-processes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. Primary Producer Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/11-consumer-processes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. Consumer Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/12-distribution-and-movement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. Distribution and Movement</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/13-processes-in-bacterial-and-inanimate-pools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">12. Processes in Bacterial and Inanimate Pools</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/14-influence-of-environmental-factors-on-ecological-p.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">13. Influence of Environmental Factors on Ecological Processes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/15-final-overview-of-ecology-routines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">14. Final Overview of Ecology Routines</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/16-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../user_guides/quarto_site/part1/17-appendix-1-tips-for-calibrating-biological-model-n.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Appendix 1: Tips for Calibrating Biological Model</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#boxes-and-layers-defining-the-geometry-of-the-model" id="toc-boxes-and-layers-defining-the-geometry-of-the-model" class="nav-link active" data-scroll-target="#boxes-and-layers-defining-the-geometry-of-the-model"><strong>3.1. Boxes and layers defining the geometry of the model</strong></a></li>
  <li><a href="#how-to-define-a-geometry-file-for-a-new-model" id="toc-how-to-define-a-geometry-file-for-a-new-model" class="nav-link" data-scroll-target="#how-to-define-a-geometry-file-for-a-new-model"><strong>3.2. How to define a geometry file for a new model?</strong></a></li>
  <li><a href="#practical-steps-for-building-the-bgm-files-from-gis-shapefiles" id="toc-practical-steps-for-building-the-bgm-files-from-gis-shapefiles" class="nav-link" data-scroll-target="#practical-steps-for-building-the-bgm-files-from-gis-shapefiles"><strong>3.3. Practical steps for building the BGM files from GIS shapefiles</strong></a></li>
  <li><a href="#how-to-view-your-model-geometry" id="toc-how-to-view-your-model-geometry" class="nav-link" data-scroll-target="#how-to-view-your-model-geometry"><strong>3.4. How to view your model geometry?</strong></a></li>
  <li><a href="#using-r-for-bgm-geometry" id="toc-using-r-for-bgm-geometry" class="nav-link" data-scroll-target="#using-r-for-bgm-geometry"><strong>3.5 Using R for BGM geometry</strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">3. GEOMETRY OF THE MODEL DOMAIN</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="boxes-and-layers-defining-the-geometry-of-the-model" class="level2">
<h2 class="anchored" data-anchor-id="boxes-and-layers-defining-the-geometry-of-the-model"><strong>3.1. Boxes and layers defining the geometry of the model</strong></h2>
<p>Atlantis is a spatially-explicit model, which means that it simulates spatial variation in biogeochemical and socio-economic processes. The spatial domain or geometry of the specific model consists of boxes or polygons subdivided into vertical sediment, water and optional ice depth layers. Land is also an optional inclusion, represented via sediment layers only. The number and shapes of boxes, as well as a number and depth of vertical layers is defined by the user. One layer of one box is called a cell. A cell is the main model spatial unit. Most biogeochemical, biological or fisheries processes are replicated in each water column cell and are considered uniform within a cell. Movement between the water column cells is by passive advective transfer (forced by hydrodynamic forcing files) or directed active movement. Only sediment relevant processes are executed in the sediments, similarly for ice or land. Direct movement between cells of these special types is not possible for ice or sediments, though some directed movement is possible on land. Movement between the special cell types and water column cells may happen due to processes like deposition and melting.</p>
<p>The advantage of using a unique model polygon and depth domain, rather than a standard grid, is that the user can match the model geometry to the geographical and bioregional features of the simulated marine system. Smaller, higher-resolution polygons can be defined in areas of particular interest (Johnson et al.&nbsp;2011) while open water areas can be modelled as one or several large polygons saving a significant amount of computational time. This means that you should think carefully about defining the model geometry (and forcing file conversion, see Chapter 4). Models focused on coastal fisheries often use bathymetry to define polygons, picking boundary isobaths that are important predictors of species distribution or fisheries management zones - such as states, provinces or marine protected areas. Oceanographers may want to isolate areas with persistent currents, eddies, or other oceanographic features. Biogeographic breaks (headlands, capes) may also be important to consider. Finally, the spatial distribution of biological and fisheries data, and the spatial scale of interest to stakeholders and other users of your model also need to be considered.</p>
<p>In principal users can setup very complex shaped polygons, however, the number of polygons and faces between them will determine the speed of calculations. Remember that all biological and fisheries process calculations are repeated in each layer of each polygon!</p>
<p><img src="media/image21.jpeg" style="width:5.80208in;height:3.48619in"></p>
<p><img src="media/image22.png" style="width:6.21661in;height:4.38904in"></p>
<p><span id="_Toc526762784" class="anchor"></span><strong>Figure 4</strong>. Top: An example cross section of an Atlantis model, showing water column and sediment layers. Oceanic boxes have an open water boundary at the bottom of the deepest water layer. The depths of vertical layers do not have to be the same in all boxes, although most models keep them identical for simplicity (shown with horizontal dashed line). The depth of the bottom water column layer varies depending on the geography of the marine system. Bottom: An example of the horizontal Atlantis model domain (set in the BGM file)</p>
</section>
<section id="how-to-define-a-geometry-file-for-a-new-model" class="level2">
<h2 class="anchored" data-anchor-id="how-to-define-a-geometry-file-for-a-new-model"><strong>3.2. How to define a geometry file for a new model?</strong></h2>
<p>The first step in developing a new model is to define the two-dimensional domain specified in the BGM file. Atlantis was created prior to the development of shapefiles that have now become a standard in GIS applications. Hence Atlantis uses its own BGM file format (see <a href="https://confluence.csiro.au/display/Atlantis/Atlantis+BGM+Files">wiki</a> BGM file page), which was a common format for many early box models. These days the developers of new Atlantis applications typically define model geometry and shapes of the polygons using GIS tools, but any other alternative approaches that can provide geographic representation can be used. The GIS tools can export shapefiles, which are converted into the Atlantis-specific BGM file using specially written packages. A new R tool (rbgm, see below) is also being developed to enable users to convert files from GIS or other spatial editing applications directly to BGM files, skipping the shapefile stage (see below). The BGM file is also used by some software packages, such as Dive or Olive, for spatial visualisation of Atlantis outputs.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Details of the model geometry are defined in the <strong>BGM</strong> and <em>intial_conditions.nc</em> files.</p>
<p>The <strong>BGM</strong> file defines the <strong>two-dimensional</strong> geometry of the model domain. It includes information on boxes, their shapes, midpoints, faces. It also specifies the maximum depth of the modelled ecosystem and maximum depth of each box.</p>
<p>The <strong><em>initial_condition.nc</em></strong> file includes further information on the <strong>three-dimensional geometry</strong>, specifying numbers and depth of the vertical layers in each box. The maximum number of water column and sediment layers is set in the global attribute section in the <em>initial_conditions.nc</em> file (wcnz and sednz parameters). The actual number of water column and the ID of the top active sediment layer (typically 0) in each box is then given in the numlayers and topk parameters given for each box.</p>
<p>Nominal or initial <strong>depths of the water column and sediment layers</strong> are set in the <em>initial_ condition.nc</em> nominal_dz parameter. Typically they are set to be identical among boxes (see Fig. 4 top panel), except for the bottom layer, but this is not strictly required. The actual depths of the water column and sediment layers can change dynamically through the simulation and are stored in the dz variable. The maximum change in water column depth is set in wc_dz_tol , whereas minimum and maximum depth of the sediments layer(s) is set in the minseddz and maxseddz parameters in the <em>physics.prm.</em></p>
<p>The optional ice layers are included as a fourth dimension in the <em>initial_conditions.nc</em> file. Modelling ice in Atlantis is still under development, see chapter 5.5.2.</p>
</div>
</div>
<p>There are <strong>two main types of boxes: dynamic and boundary</strong>. The corners of each polygon are defined by <strong>vertices</strong> and the lines connecting these corners are called <strong>faces</strong>.</p>
<p><img src="media/image23.jpg" style="width:6in;height:6in"></p>
<p><span id="_Toc446445864" class="anchor"></span><strong>Figure 5</strong>. Example of an Atlantis model geometry (part of a model domain). Boxes are numbered in bold, grey boxes indicate boundary or island (land) boxes. Faces are numbered in <em>italic</em> numbers. Vertices are shown as dots; vertices P1 and P2 describe face 5.</p>
<p><strong>Dynamic boxes</strong> make up the model domain; all biological and socio-economic processes are modelled in them. Dynamic boxes must satisfy the (approximate) requirement of mass conservation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, although their volume can change slightly due to currents and tides (just as seen in the real world). In dynamic boxes numeric fluxes of a tracer (e.g.&nbsp;NO3, phytoplankton) due to ecological processes (such as growth and mortality) cannot exceed a certain proportion of its standing biomass. This proportion is set by the RelTol parameter in the <em>biology.prm</em> file (but see the note below on relax_tol).</p>
<p><strong>Boundary boxes</strong> are used only as sources and sinks for advective transport. They represent the “outer world” or the system beyond the model domain and don’t have the requirement of mass conservation. The areas of boundary boxes play no role (they can be set as tiny slivers or large boxes) and there are no water or tracer movements between boundary boxes. Islands inside the model domain are modelled as boundary boxes (unless land has been activated in the model by setting flagAllowLand to 1 in the <em>run.prm</em> file). In models where land is not active islands and other land boxes have zero depth (box 8 in the Fig. 5). However, when land is active (only in the most recently development versions of Atlantis) explicit modelling of land is allowed (see chapter 5.5.1), these boxes use a positive value for total box depth (botz) rather than the negative values used for aquatic boxes.</p>
<p>In the vertical dimension the polygons can be either <strong>non-oceanic</strong> or <strong>oceanic</strong>. Sometimes the Atlantis model does not capture the full depth of the marine ecosystem. For example, the actual maximum depth in the modelled ocean area can be 3500 m (shown in the maxbotz parameter in the BGM file), but the model domain only includes the top 2000m (box-specific botz parameters in the BGM file). The polygons for which botz is greater or equal to maxbotz are classified as oceanic (e.g.&nbsp;a maxbotz of -2000 versus a botz of -3500). This means that the bottom water layer in these polygons has an open water boundary with deeper (not explicitly modelled) waters rather than with a sediment layer. In oceanic boxes the sediment layer is still included in the setup (for simplicity) but sediment calculations are not performed in these boxes when the model is run and the biomass of organisms in the sediments are not included in the total biomass calculations. Further, the deepest layers of the oceanic boxes receive nutrient input from “outside” of the model domain, designed to simulate nutrient mixing from deeper layers not included in the model domain.</p>
<p>Below is an example of a BGM file with explanations of parameters given after #</p>
<pre><code># box model geometry based on VMPA_setas_20051216.bgm

# conversion from lat/long space to x-y space of the model domain. Required for mapping and light level
# calculations (when lim_sum_hours is turned on in the biology.prm file). Definition is based on GIS standards
# The parameters should be space separated
projection proj=aea lat_1=-18 lat_2=-36 lat_0=0 lon_0=134 x_0=3000000 y_0=6000000 ellps=GRS80 towgs84=0,0,0,0,0,0,0 units=m no_defs

# Number of boxes in horizontal plane
nbox 11

# Number of faces in horizontal plane
nface 22

# Maximum bottom depth (m) of the model domain (not the real ecosystem)
maxwcbotz -5000

# vertices of the polygon defining the boundary of the dynamic model space throughout the total geographical
# extent of the model, creating one big polygon. They are ordered sequentially in either clockwise or
# anticlockwise direction (it doesn't matter which so long as it remains consistent) in (x,y) format, where x,y is
# in projected (linear transformation) of longitude and latitude
bnd_vert 4227984.241 1449270.8
bnd_vert 4279136.436 1451037.995
bnd_vert 4684173.263 1362498.346
# ... and so on for all vertices

# Data for box number 0 ## user defined box number identifier
box0.label Box0  ## users reference box name, e.g. Box0 or Sydney Harbour
box0.inside 4043667.571 1150676.493  ## midpoint of polygon
box0.nconn 5  ## number of faces shared with other dynamic boxes
box0.iface 1 10 11 13 17  ## id numbers of shared faces, each face has a unique id
box0.ibox 0 2 2 2 2  ## box that each shared face corresponds to
box0.botz -370  ## maximum depth of the polygon in the real ecosystem
box0.area 3261982282  ## area of the box, m²
box0.vertmix 0.000001  ## vertical mixing scalar for the polygon
box0.horizmix 1  ## horizontal transport scalar for the polygon
box0.relax_tol 0  ## whether relaxing flux tolerance for this box
box0.vert 4005591.597 1198429.099  ## List of vertices (x,y) in clockwise or counter clockwise order
box0.vert 3998613.455 1174049.433
box0.vert 4065533.389 1102640.49
box0.vert 4095090.658 1128446.461
box0.vert 4095245.855 1128504.676
box0.vert 4005591.597 1198429.099

# ... and so on for all boxes

# This section describes each dynamic face (faces of all non-boundary boxes)
# Data for face number 0
face0.p1 4005591.597 1198429.099  ## one endpoint of face (x1,y1)
face0.p2 4095245.855 1128504.676  ## other endpoint of face (x2,y2)
face0.length 113698.3335  ## length of face
face0.cs -0.788527462 0.614999546  ## Cosine and sine of the slope of the face (slope=sine/cosine)
face0.lr 2 0  ## Number of the box to the left and to the right as you look
## from point 1 to point 2. Correct orientation is crucial! (see below)

# ... and so on for all faces</code></pre>
<div class="callout callout-style-default callout-caution callout-titled" title="Relaxing the flux tolerance check for an individual box">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Relaxing the flux tolerance check for an individual box
</div>
</div>
<div class="callout-body-container callout-body">
<p>There are times (e.g.&nbsp;during an extreme event, which might be implemented for a specific scenario, or if including restocking/replanting of seagrass for example) when the flux of a variable can legitimately be at a level that would breach the flux tolerance checks in place to ensure numerical stability (as conditioned by RelTol set in the <em>biology.prm</em>). To allow for this there is a property per box in the BGM file, box#.relax_tol , which is typically set to 0 unless absolutely required.</p>
</div>
</div>
<p><strong>Below are some strict rules and best practice suggestions on setting up the model geometry.</strong> These rules are provided here to give general insights into how the geometry file is setup. If you are developing a BGM file for a new model, check more detailed instructions on Atlantis wiki (links given below).</p>
<p><strong>Rules:</strong></p>
<ol type="1">
<li><p>Box 0 <strong>must</strong> be a <strong>boundary</strong> box and Box 1 <strong>must</strong> be a <strong>dynamic</strong> box. This rule is a developmental legacy and determined by the way the Atlantis code and oceanographic file conversion was setup during the model development. Box 0 is special because it is set up to have water and nutrient fluxes to nearly all other model boxes. This is set to simulate supply of advective tracers to the oceanic boxes and accommodate any missing water fluxes due to conversion of oceanographic files into Atlantis input files (see chapter 4). While the model is running it also acts as a store for information on any migrating groups currently outside the model domain.</p></li>
<li><p><strong>Doughnut shaped boxes are not allowed</strong>. For example, you cannot have one box around an island. This is because such boxes have their midpoint on land, which would affect calculations of a number of processes relying on midpoint values.</p></li>
<li><p>The description of boxes, faces and vertices in the BGM file (iface, ibox, bnd_vert parameters) <strong>must be done in the same orientation</strong> – clockwise or counter clockwise. It doesn’t matter which you chose, just make sure it is consistent throughout. The orientation can be checked using the <a href="https://confluence.csiro.au/display/Atlantis/Checkwinding">Checkwinding</a> package developed by Cameron Ainsworth and available from the Atlantis wiki.</p></li>
<li><p>Islands <strong>must</strong> be represented as boxes with a depth of 0 (or &gt;0 if land is active), not as empty regions. By default the land boxes are either treated as boundary boxes, but can also be modelled as land, if the land option is activated (see chapter 5.5.1).</p></li>
<li><p>It is of utmost importance to <strong>correctly identify the boxes to the left and to the right of a face</strong> in the <code>face#.lr</code> parameter (where # stands for the box number). The points P1 and P2 in the Figure 3 describe face 5 between boxes 2 and 6. If <code>face5.p1</code> is given as P1 and <code>face5.p2</code> is P2, then left and right boxes are designated as you look from P1 to P2. This means the right box is 6 and the left box is 2 and <code>face5.lr</code> must be set as 2 6. Setting the direction incorrectly inverts the direction of the flow in the hydrodynamics forcing file! <a href="https://confluence.csiro.au/display/Atlantis/Checkwinding">Checkwinding</a> package will check the file for correct right/left designation.</p></li>
<li><p>The <strong>midpoint</strong> of a polygon is defined in the <code>box#.inside</code> parameter. It is used to: i) calculate the temperature in a box when temperature forcing data is not provided and we are in the southern hemisphere; ii) calculate the sunrise and sunset values based on lat/long when lim_sun_hours is set to 1; iii) calculate distance between boxes and invasion speed if the invasion option is active; iv) calculate distance from a box to a port in the dynamic fishing code. <strong>If the midpoint of the box is misplaced and is not within the actual box, Atlantis will quit when trying to read time series that deposit something into that box or when running dynamic fishing routines.</strong></p></li>
</ol>
<p><strong>Suggestions:</strong></p>
<ol start="7" type="1">
<li><p>Keep the number of boxes as small as possible (fewer than 90 is good), remember the fewer the boxes the faster the model will run (e.g.&nbsp;models with 20-30 boxes will run three to four times faster than one with 90 boxes!)</p></li>
<li><p>Keep the number of dynamic faces (those corresponding to non-boundary boxes) to less than 400, but 100-200 would be even better! It is not recommended to have boxes with very complex shapes (i.e.&nbsp;do not slavishly follow complex isobaths in the GIS when drawing up the box shapes). This is because complex box shapes are 1) is prone to error and 2) may give a false impression of reality. Simple shaped boxes serve as a good reminder that the spatial results presented are only model simulations and should be treated as such.</p></li>
<li><p>When setting up box shapes in GIS, make sure the topology is perfect, which means no gaps or overlaps between polygons. If the shapefile has overlaps or gaps it won’t convert to the BGM file.</p></li>
</ol>
<p><img src="media/image25.png" style="width:4in;height:2.5in"></p>
<ol start="10" type="1">
<li>In some cases conversion of water fluxes from oceanographic files to Atlantis hydrodynamic forcing files leaves small coastal boxes isolated, i.e.&nbsp;no water fluxes enter or leave them. This will be covered in more detail in Chapter 5.4. The BGM file has two box-specific water mixing parameters that are used in some physics routines, including those used to correct for the lack of mixing. These parameters allow box-specific mixing scalars to be setup and help to tune vertical and horizontal water flows in the model domain:</li>
</ol>
<p><code>box#.vertmix</code> - vertical mixing scalar used only when vert_diffusion or vert_mix are turned on in the <em>physics.prm</em>.</p>
<p><code>box#.horizmix</code> – horizontal mixing scalar that can be used to correct for hyperdifusion (if insufficient correction was done during the file conversion stage, see Chapter 5.4). It is also used as a box-specific scalar if fill_zero_exchange or horiz_diffusion flags are turned on (set to 1) in the <em>physics.prm</em> file (see Chapter 5 for further details).</p>
</section>
<section id="practical-steps-for-building-the-bgm-files-from-gis-shapefiles" class="level2">
<h2 class="anchored" data-anchor-id="practical-steps-for-building-the-bgm-files-from-gis-shapefiles"><strong>3.3. Practical steps for building the BGM files from GIS shapefiles</strong></h2>
<p><strong>1.</strong> Define polygons using QGIS or similar GIS package. This will produce a shapefile of the model domain. The shapefile is the master of the model geometry, any changes should be made to the shapefile and the BGM should be recreated from that master. Hand editing of the BGM should be avoided<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, other than to manually set the box-specific mixing values, or to correct any issues resulting from BGM generation (like misplacement of the inside point). See the <a href="https://confluence.csiro.au/display/Atlantis/Atlantis+BGM+Files">Atlantis wiki</a> BGM file page for more information.</p>
<p><strong>2.</strong> Run the BGMeriser package, to convert shapefiles into BGM files. Details on access and installation are given on the wiki (<a href="https://confluence.csiro.au/display/Atlantis/Technical+Information">here)</a> as are details on how to run it (<a href="https://confluence.csiro.au/display/Atlantis/BGMEditor">here</a>).</p>
<p><strong>3.</strong> If the shapefiles do not pass through the BGMeriser, they probably have issues with gaps or overlapping polygons and should be cleaned. Check the <a href="https://confluence.csiro.au/display/Atlantis/Using+QGIS+to+clean+Atlantis+BGM+Shapefiles">instructions</a> on the wiki for tips on cleaning up the shapefiles using QGIS.</p>
<p><strong>4.</strong> Use <a href="https://confluence.csiro.au/display/Atlantis/Checkwinding">Checkwinding</a> to check the orientation of boxes and faces in the BGM file</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Please keep in mind that <strong>shapefiles do not preserve all information about the faces</strong> among the boxes (see chapter 3.5). Shapefiles only enumerate faces, but they do not give information about their orientation. They also do not preserve topological information among boxes, i.e.&nbsp;their relationship to one another. Correctly created shapefiles include user defined extra attributes to contain the additional information required to generate a BGM file. However, when shapefiles are edited in a GIS, all face information may change, especially if some boxes are added or deleted. This is why BGMeriser must be run after each shapefile amendment. This is an important disadvantage of using shapefiles for Atlantis model geometry and a <strong>new R package is being developed</strong> to allow users create BGM files directly from GIS or other applications, without having to use shapefiles (see chapter 3.5).</p>
</div>
</div>
</section>
<section id="how-to-view-your-model-geometry" class="level2">
<h2 class="anchored" data-anchor-id="how-to-view-your-model-geometry"><strong>3.4. How to view your model geometry?</strong></h2>
<p>The two-dimensional model geometry is now defined in your shapefiles and in BGM files. <strong>The shapefiles can be viewed using QGIS or a similar GIS package.</strong> If shapefiles are not available, BGM files can be converted into shapefiles using <a href="https://confluence.csiro.au/display/Atlantis/BGM2SHP">BGM2SHP</a> package.</p>
<p>The BGM files are also read by various tools used to visualise Atlantis outputs in a spatial context, listed in chapter 2.9</p>
</section>
<section id="using-r-for-bgm-geometry" class="level2">
<h2 class="anchored" data-anchor-id="using-r-for-bgm-geometry"><strong>3.5 Using R for BGM geometry</strong></h2>
<p>There is an R package <a href="https://github.com/mdsumner/rbgm"><strong><em>rbgm</em></strong></a> for working with BGM files contributed by Michael Sumner. The aim of the package is to provide a common platform for reading and writing BGM files, which then also can be used by other Atlantis R applications that require information on the model geometry. Generally, shapefiles do not store all information required to completely re-create a BGM file. One needs at least a line shapefile and a polygon shapefile to store what is in the BGM and also some notes to go with it, which is why a shapefile is only a starting point for a BGM file. Note that BGMeriser <strong>will</strong> create a valid BGM file from a shapefile, but it has to be configured <a href="https://confluence.csiro.au/display/Atlantis/BGMEditor">in the right way</a>.</p>
<p>Using <strong><em>rgbm</em></strong> you can</p>
<ul>
<li><p>read the BGM format, maintaining all topology and attributes</p></li>
<li><p>convert from BGM to GIS-like objects using the Spatial tools in R (<strong>sp</strong> package)</p></li>
</ul>
<p>The “GIS-like” object is an R equivalent of a “shapefile”, which consists of “layers” of geometric shapes (polygons, lines, or points) that are linked to a table of attributes. The BGM geometry is really a combination of information on lines (faces) and polygons (boxes), where each face has information about its orientation and its neighbouring faces and boxes. R uses Spatial layers for separate description of a SpatialPolygonsDataFrame (a polygon shapefile), SpatialLinesDataFrame (a line shapefile) and SpatialPointsDataFrame (a point shapefile).</p>
<p>Once the BGM is loaded in R, it can be used to visualise faces and boxes as lines and polygons, and use these objects to extract data from other sources, like doing spatial queries with other map data, extracting gridded data summaries, and using these for visualization or further analysis (see rbgm description for further information). A goal for <strong><em>rbgm</em></strong> is to drive coupling of Atlantis with physical data and models via R. <strong><em>rbgm</em></strong> is able to write from Spatial forms to shapefiles and other formats, but since we can read directly from BGM or from a GIS or geodatabase, this also means that we don’t necessarily need to create shapefiles at all (soon <strong>rbgm</strong> will be able to create BGM files after reading the input from QGIS or Manifold GIS projects).</p>
<p>A collection of <a href="https://github.com/AustralianAntarcticDivision/box-geometry-models">publicly available BGM files from existing Atlantis models</a> is also available. This collection can be viewed using an R package <a href="https://github.com/AustralianAntarcticDivision/bgmfiles"><strong><em>bgmfiles</em></strong></a>.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>A small amount of mismatch (typically to cover rounding error) is allowed over the total fluxes in a cell in any one time step, but if it becomes too large (i.e.&nbsp;exceeds the flux tolerance set in the biology.prm file, with typical values being on the order of 0.2 mgN*m-3 per second) the model will quit and provide a warning message, as this indicates that there is a problem with the parameterisation<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Expert users may be able to tinker directly with the BGM file, but extreme care should be taken and it should be documented so any future users can understand the changes made (as the master shapefile file will no longer 100% match the model geometry).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>