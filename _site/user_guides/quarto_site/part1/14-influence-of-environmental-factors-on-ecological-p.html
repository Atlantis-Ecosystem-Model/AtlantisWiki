<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Atlantis Documentation – 13. INFLUENCE OF ENVIRONMENTAL FACTORS ON ECOLOGICAL PROCESSES</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Atlantis Documentation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-user-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">User Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-user-guides">    
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part1/index.html">
 <span class="dropdown-text">Part I - Atlantis User Guide</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../user_guides/quarto_site/part2/index.qmd">
 <span class="dropdown-text">Part II - [Coming Soon]</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../confluence/index.html"> 
<span class="menu-text">Confluence Wiki</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resources/index.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#temperature-two-methods-to-get-temperature-scalar" id="toc-temperature-two-methods-to-get-temperature-scalar" class="nav-link active" data-scroll-target="#temperature-two-methods-to-get-temperature-scalar"><strong>13.1. Temperature: two methods to get temperature scalar</strong></a></li>
  <li><a href="#temperature-effects-on-feeding-parameters-and-assimilation-efficiency" id="toc-temperature-effects-on-feeding-parameters-and-assimilation-efficiency" class="nav-link" data-scroll-target="#temperature-effects-on-feeding-parameters-and-assimilation-efficiency"><strong>13.2. Temperature: effects on feeding parameters and assimilation efficiency</strong></a></li>
  <li><a href="#salinity" id="toc-salinity" class="nav-link" data-scroll-target="#salinity"><strong>13.3. Salinity</strong></a></li>
  <li><a href="#acidification" id="toc-acidification" class="nav-link" data-scroll-target="#acidification"><strong>13.4. Acidification</strong></a></li>
  <li><a href="#oxygen" id="toc-oxygen" class="nav-link" data-scroll-target="#oxygen"><strong>13.5. Oxygen</strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">13. INFLUENCE OF ENVIRONMENTAL FACTORS ON ECOLOGICAL PROCESSES</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="temperature-two-methods-to-get-temperature-scalar" class="level2">
<h2 class="anchored" data-anchor-id="temperature-two-methods-to-get-temperature-scalar"><strong>13.1. Temperature: two methods to get temperature scalar</strong></h2>
<p>Temperature can have a large influence on many biogeochemical and ecological processes, but in Atlantis the user has an option to turn the temperature effects off, by setting flagq10=0 (NOT recommended given the fundamental temperature dependence of most physiological processes). Temperature effects are mostly applied through the Tcorr scalar calculated in the <em>Get_Tcorr()</em> routine. Setting flagq10=0 means that Tcorr scalar will be set to 1.</p>
<p>There are two ways to calculate the Tcorr scalar and different methods can be applied for different species, selected with the q10_method_XXX parameter. Some details on the calculations are given <a href="https://confluence.csiro.au/display/Atlantis/Effect+of+temperature+on+functional+groups">here</a>.</p>
<p>If the q10_method_XXX=0 then a simple Q10 based correction scalar is calculated, using the reference temperature of 15C:</p>
<p><span class="math display">\[T_{scalar} = {q10}^{\frac{\left( T_{H2O} - 15 \right)}{10}}\]</span></p>
<p>where q10 is a species-specific parameter provided in the q10_XXX and is typically set to 2. The Figure 19 shows the effect of different q10_XXX values.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image60.emf" style="width:4.34861in;height:3.28333in" class="figure-img"></p>
<figcaption><span id="_Toc526762799" class="anchor"></span>Figure 19. The <em>T<sub>scalar</sub></em> values at different water temperatures.</figcaption>
</figure>
</div>
<p><strong>Black</strong>: q10=2</p>
<p><strong>Orange</strong>: q10=2.5</p>
<p><strong>Red</strong>: q10=3</p>
<p>A more complicated six parameter function is used if q10_method_XXX=1 (based on Gary Griffiths PhD thesis)</p>
<p><span class="math display">\[Tcorr = ln(2) \bullet \phi_{A} \bullet {Cons}_{B}^{Temp} \bullet \text{exp}\left( - \phi_{C} \bullet \frac{\left| Temp - {Temp}_{OPT} \right|^{Cons}}{\phi_{corr}} \right)\]</span></p>
<p>where <em>ø<sub>A</sub></em> is a species-specific coefficient (temp_coefftA_XXX), <em>Cons<sub>B</sub></em> is the global coefficient (temp_coeffB), <em>Temp</em> is ambient water temperature<em>, Temp<sub>OPT</sub></em> is a species-specific optimum temperature (q10_optimal_temp_XXX), <em>ø<sub>C&nbsp;</sub></em>is the global coefficient (temp_coeffC), <em>Cons</em> is a global exponent parameter (temp_exp), and <em>ø<sub>corr</sub></em> is a species q10 correction parameter (q10_correction_XXX).</p>
<p>This function aims to imitate a humped response, where rates are highest at optimum temperature levels and decrease when the temperature is below or above the optimum. The function is very sensitive to changes in parameters and before applying it the users should carefully explore the shape of the function for the chosen parameter values (Figure 20). The black line shows the shape of the response curve for the original parameter values, except for <em>Temp<sub>OPT</sub></em> which was chosen to be 19C</p>
<p>ø<sub>A</sub> (temp_coefftA_XXX) =0.85</p>
<p>Cons<sub>B</sub> (temp_coeffB) = 1.06</p>
<p>Temp<sub>OPT</sub> (q10_optimal_temp_XXX) = 19C</p>
<p>ø<sub>C</sub> (temp_coeffC) = 1</p>
<p>Cons (temp_exp) = 3</p>
<p>ø<sub>corr</sub> (q10_correction_XXX) = 1000</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image61.emf" style="width:5.05486in;height:3.46944in" class="figure-img"></p>
<figcaption><span id="_Toc526762800" class="anchor"></span>Figure 20. A humped temperature response used when q10_method_XXX=1.</figcaption>
</figure>
</div>
<p><strong>Black</strong>: original values as shown in parentheses below</p>
<p><strong>Grey</strong>: Temp<sub>OPT</sub> = 12C (19C)</p>
<p><strong>Green</strong>: ø<sub>A</sub>= 0.95 (0.85)</p>
<p><strong>Orange</strong>: Cons<sub>B</sub> = 1.1 (1.06)</p>
<p><strong>Blue</strong>: ø<sub>C</sub> = 1.1 (1.0)</p>
<p><strong>Pink</strong>: Cons = 2.5 (3.0)</p>
<p><strong>Purple</strong>: ø<sub>corr</sub> = 100 (1000)</p>
</section>
<section id="temperature-effects-on-feeding-parameters-and-assimilation-efficiency" class="level2">
<h2 class="anchored" data-anchor-id="temperature-effects-on-feeding-parameters-and-assimilation-efficiency"><strong>13.2. Temperature: effects on feeding parameters and assimilation efficiency</strong></h2>
<p>Once the Tcorr scalar has been calculated for the species and its ambient temperature in the cell using one of the two methods above, it is applied as a scalar to a range of processes. Typically, parameters that are scaled by Tcorr are indicated with T15, but this is not always the case.</p>
<p><em>A) Primary producers</em></p>
<p>In all primary producers the Tcorr scalar is applied to the light saturation (KI_XXX_T15) and maximum growth rate parameter (mum_XXX_T15)</p>
<p><em>B) Consumer feeding parameters</em></p>
<p>For <strong><em>biomass pools</em></strong> the C_ and mum_ values in the biological parameter file are given as rates at 15C and they are <strong>always</strong> scaled (multiplied) by Tcorr scalar for a given water temperature in a cell.</p>
<p>For <strong>age structured groups</strong> the search volume (vl_a) is always scaled by Tcorr, but the temperature scaling of C_ and mum_ is applied <strong>only</strong> if flagtempsensitiveXXX is set to 1. This is an inherited convention form the models the approaches were taken from and may change in the future.</p>
<p><em>C) Consumer assimilation efficiency – optional</em></p>
<p>Atlantis has an option to set improved or decreased assimilation efficiency depending on the temperature. There is no clear consensus in the ecological community on how temperature affects assimilation efficiency (it appears to be taxa specific); hence the user can decide whether to use this option.</p>
<p>To allow for temperature effect on assimilation efficiency set flagq10effXXX to 1</p>
<p>When <strong>flagq10effXXX = 1</strong> the <strong>efficiency is poorer in cooler water</strong> and the Tcorr scalar (Fig. 20) is applied <strong>only</strong> if water temperature is lower than the optimum or reference level (depending on the q10_method_XXX used).</p>
<p>If <strong>flagq10effXXX= 2</strong> the <strong>efficiency is poorer in warmer water</strong> and the Tcorr scalar (see Fig. 20) is applied <strong>only</strong> if water temperature is higher than the optimum or reference level (depending on the q10_method_XXX used).</p>
<p>In the calculations above if the Tcorr is &gt;1 then the Tcorr=1/T_scalar. This means that Tcorr is always &lt;1, which ensures that efficiency is decreased when correcting for temperature effects.</p>
<p><em>D) Mortality</em></p>
<p>For all species the linear mortality (mL), quadrating mortality (mQ) and extra mortality (mS) values are scaled by Tcorr.</p>
<p><em>E) Physical parameters</em></p>
<p>Parameters that determine the rate of breakdown are all scaled by the Tcorr scalar. They include:</p>
<p>r_DL_T15 – rate of labile detritus breakdown (day<sup>-1</sup>)</p>
<p>r_DC_T15 – rate of carrion breakdown (day<sup>-1</sup>)</p>
<p>r_DR_T15 – rate of refractory detritus breakdown (day<sup>-1</sup>)</p>
<p>r_DON_T15 – rate of dissolved organic nitrogen breakdown (day<sup>-1</sup>)</p>
<p>r_DSi_T15 – rate of detrital silica breakdown (day<sup>-1</sup>)</p>
<p>K_nit_T15 – rate of nitrification by free bacteria (mgN day<sup>-1</sup>)</p>
</section>
<section id="salinity" class="level2">
<h2 class="anchored" data-anchor-id="salinity"><strong>13.3. Salinity</strong></h2>
<p>The <strong>salinity</strong> effects on <strong>biomass pool and age structured group</strong> physiological processes are modelled through an optional Scorr, designed to reflect the sensitivity of physiological processes to salinity conditions. The Scorr scalar is not calculated dynamically, but supplied by the user in salt_correction_XXX parameter. The Scorr scalar is applied only if:</p>
<p>1) an organism is identified as sensitive to salinity, with flagSaltSensitive_XXX</p>
<p>2) an organism an outside the salinity limits defined with XXX_min_salt and XXX_max_salt</p>
<p><strong>The Scorr scalar is applied in the same way as for the Tcorr scalar described above. For age structured groups the Scorr cannot be applied alone without applying the Tcorr scalar.</strong> This means that if a species is identified as sensitive to salinity, but NOT sensitive to temperature, the Scorr scalar will not be applied to the physiological processes that have optional temperature scaling. This is not the case for biomass pool groups, where Scorr is applied regardless.</p>
</section>
<section id="acidification" class="level2">
<h2 class="anchored" data-anchor-id="acidification"><strong>13.4. Acidification</strong></h2>
<p>Atlantis has an option to include effects of acidification on different physiological processes, predatory interactions and non-predation mortality. The pH effects are activated by setting flagmodelpH to 1 and flagpHsensitive_XXX to 1.</p>
<p>The calculation of the pH correction scalar (pHCorr) is described in detail on wiki <a href="https://confluence.csiro.au/display/Atlantis/2012/10/19/Handling+effects+of+acidification">here</a>.</p>
<p>Briefly, depending on the pH_sensitivity_model selected, Atlantis will calculate the pHCorr using monodynamic, non-linear, linear, piecewise or quadratic approaches (see link above for details). The scalar will be &lt;1 at decreasing pH values. It can be based on the pH values of ∆ [H+] (set flag_use_deltaH to 1 to use ∆ [H+]).</p>
<p>As for the Scorr scalar, <strong>for age structured groups</strong> the pHCorr will be applied to the processes affected by temperature (feeding rates, assimilation efficiency, mortality), <strong>only if a species is sensitive to pH</strong> (flagpHsensitive_XXX=1) <strong>and sensitive to temperature.</strong></p>
<p>The pH can also affect other processes, as listed in Table 26.</p>
<p><span id="_Toc526762778" class="anchor"></span>Table 26. Effects of pH on physiological and ecological processes. See detailed description <a href="https://confluence.csiro.au/display/Atlantis/2012/10/19/Handling+effects+of+acidification">here</a></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><strong>What is affected</strong></th>
<th><strong>How to activate</strong></th>
<th><strong>How is it applied</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>Processes for which pHcorr scalar is applied at the same time as the Tcorr scalar, described in chapter 13.2</em></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Growth and non-predation mortality rates</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>For age structured groups it is applied only if:</p>
<p>flagtempsensitiveXXX=1</p></td>
<td>Growth and non-predation mortality are affected in opposite ways by pH. The unmodified C and mum will be multiplied by pHCorr (and decrease as a result) and the unmodified mL and mQ multiplied by 1.0/pHCorr (and increase)</td>
</tr>
<tr class="odd">
<td>Search volume (if predcase=5)</td>
<td>flagpHsensitive_XXX=1</td>
<td><p>The vla_T15 is multiplied by pHCorr (and decreases)</p>
<p>This is only applied for age structured groups</p></td>
</tr>
<tr class="even">
<td>Assimilation efficiency</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagtempsensitiveXXX=1</p>
<p>flagq10eff_XXX=1 or 2</p></td>
<td>Four assimilation efficiencies are multiplied by pHCorr (and decreases)</td>
</tr>
<tr class="odd">
<td><em>Processes for which pHcorr scalar is applied differently from Tcorr scalar</em></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Availability of prey to predators</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagpredavaileffect_XXX = 1</p></td>
<td><p>For <strong>biomass pool prey</strong> availability to predators (defined in pPREY or ontogenetic diet matrices) is <strong>increased</strong> multiplying by 1.0/pHCorr</p>
<p>For <strong>age structured group prey</strong> availability to predators (defined in pPREY or ontogenetic diet matrices) is <strong>decreased</strong> multiplying by pHCorr</p></td>
</tr>
<tr class="odd">
<td>Nutritional content of a species to its predators; mostly intended to simulate nutritional content of primary producers</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagnutvaleffect_XXX=1</p></td>
<td>The amount of prey biomass available to a predator (defined in pPREY or ontogenetic diet matrices) is further multiplied by pHCorr (ot represent that more must be eaten to get the same nutritional content) and in this way decreased, reflecting lower nutritional content</td>
</tr>
<tr class="even">
<td>Reduced larval survival before recruitment</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagfecundsensitive_XXX =1</p></td>
<td>The number of recruits is multiplied by pHCorr and therefore decreased</td>
</tr>
<tr class="odd">
<td>Modifying thermal tolerance of a species</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagcontract_tol_XXX = 1</p></td>
<td>The thermal tolerance decreases according to contract_tol_XXX parameter which defined the number of degrees to contract the temperature tolerances by as pH drops</td>
</tr>
<tr class="even">
<td>Additional mortality</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>flagPHmortcase &gt;0</p></td>
<td>Extra mortality applied for ALL groups</td>
</tr>
<tr class="odd">
<td>Extra mortality</td>
<td><p>flagpHsensitive_XXX=1</p>
<p>pHmortstart = 1</p></td>
<td>Another logistic extra mortality term is added, see details <a href="https://confluence.csiro.au/display/Atlantis/2015/05/14/Acidification+induced+mortality">here</a></td>
</tr>
</tbody>
</table>
</section>
<section id="oxygen" class="level2">
<h2 class="anchored" data-anchor-id="oxygen"><strong>13.5. Oxygen</strong></h2>
<p>The oxygen dependency is modelled differently from the temperature, salinity and pH effects described above. The oxygen content of the water does not affect the physiological processes, but recruitment and distributions. It also can lead to oxygen stress induced mortality of biomass pool groups.</p>
<p>The effect of oxygen limitation on feeding rates and linear mortality of biomass pool groups is non-optional and is modelled with O2case, mO_XXX, mD_XXX, KO2_XXX and KO2LIM_XXX parameters</p>
<p>The sensitivity of distributions and recruitment on oxygen concentration is optional. It is applied to both age structured groups and biomass pools and is activated by a global flagO2depend parameter and species-specific minimum oxygen concentrations XXX_min_O2 parameter, setting the minimum tolerated oxygen level. If this option is used then species distribution will contract to areas above the minimum oxygen level. Further, the recruits that arrive into cells with oxygen concentrations lower than the minimum will be killed (not contracted!, see chapter 10.9.3.).</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>